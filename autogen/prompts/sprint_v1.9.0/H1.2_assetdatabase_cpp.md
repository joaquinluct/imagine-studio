# Prompt - H1.2: Implementar AssetDatabase.cpp

## Context
- Sprint: v1.9.0 - Asset System & Resource Management
- Task: H1.2 - Implementar AssetDatabase.cpp
- Files to read: docs/daily.md, docs/sprint_tasks.md, src/assets/AssetDatabase.h

## Implementation Details
- Create file: src/assets/AssetDatabase.cpp
- Implement methods:
  - `AssetDatabase& Instance()` - Singleton pattern with static local
  - `AssetID ImportAsset(const std::string& path)` - Import asset from disk, detect type, generate ID, store metadata
  - `AssetMetadata* GetAsset(AssetID id)` - Return pointer to metadata or nullptr
  - `AssetID GetAssetByPath(const std::string& path)` - Lookup ID by path
  - `void RefreshAssets()` - Re-scan asset folders
  - `AssetID GenerateID()` - Return m_nextID++
  - `AssetType DetectType(const std::string& path)` - Detect type by extension (.png/.jpg = Texture, .obj = Mesh, .hlsl = Shader, .scene = Scene)

- Include order: Project headers first ("AssetDatabase.h"), then system headers (<filesystem>, <fstream>)
- Namespace: Assets
- Encoding: UTF-8 with BOM, CRLF line endings
- Use std::filesystem for file operations

## Expected Implementation
```cpp
#include "AssetDatabase.h"
#include <filesystem>
#include <fstream>

namespace Assets {

AssetDatabase& AssetDatabase::Instance() {
    static AssetDatabase instance;
    return instance;
}

AssetID AssetDatabase::ImportAsset(const std::string& path) {
    namespace fs = std::filesystem;
    
    // Check if already imported
    auto it = m_pathToID.find(path);
    if (it != m_pathToID.end()) {
        return it->second;
    }
    
    // Check file exists
    if (!fs::exists(path)) {
        return 0; // Invalid ID
    }
    
    // Generate metadata
    AssetID id = GenerateID();
    AssetMetadata meta;
    meta.id = id;
    meta.path = path;
    meta.name = fs::path(path).filename().string();
    meta.type = DetectType(path);
    meta.size = fs::file_size(path);
    meta.lastModified = fs::last_write_time(path).time_since_epoch().count();
    
    // Store
    m_assets[id] = meta;
    m_pathToID[path] = id;
    
    return id;
}

AssetMetadata* AssetDatabase::GetAsset(AssetID id) {
    auto it = m_assets.find(id);
    if (it != m_assets.end()) {
        return &it->second;
    }
    return nullptr;
}

AssetID AssetDatabase::GetAssetByPath(const std::string& path) {
    auto it = m_pathToID.find(path);
    if (it != m_pathToID.end()) {
        return it->second;
    }
    return 0;
}

void AssetDatabase::RefreshAssets() {
    // TODO: Implement in future task (H1.3)
}

const std::unordered_map<AssetID, AssetMetadata>& AssetDatabase::GetAllAssets() const {
    return m_assets;
}

AssetID AssetDatabase::GenerateID() {
    return m_nextID++;
}

AssetType AssetDatabase::DetectType(const std::string& path) {
    namespace fs = std::filesystem;
    std::string ext = fs::path(path).extension().string();
    
    if (ext == ".png" || ext == ".jpg" || ext == ".jpeg") {
        return AssetType::Texture;
    } else if (ext == ".obj") {
        return AssetType::Mesh;
    } else if (ext == ".hlsl") {
        return AssetType::Shader;
    } else if (ext == ".scene") {
        return AssetType::Scene;
    }
    
    return AssetType::Unknown;
}

} // namespace Assets
```

## Workflow
1. Planner: Read docs/sprint_tasks.md and src/assets/AssetDatabase.h, propose implementation plan
2. Coder: Implement AssetDatabase.cpp with C++14 syntax, UTF-8 with BOM, CRLF
3. Reviewer: Review code quality (include order, AAA standards, namespace, singleton pattern)
4. Tester: Compile with CMake and MSBuild (0 errors, 0 warnings)

Please proceed step by step.

---
**Version**: 1.0
**Last update**: 2025-10-21
**Sprint**: v1.9.0
**Task**: H1.2
